{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Graphery Documentations Introduction Coming Soon~ Usage Please use the navigation to get more info~","title":"Home"},{"location":"#welcome-to-graphery-documentations","text":"","title":"Welcome to Graphery Documentations"},{"location":"#introduction","text":"Coming Soon~","title":"Introduction"},{"location":"#usage","text":"Please use the navigation to get more info~","title":"Usage"},{"location":"about/","text":"About Coming Soon~","title":"About"},{"location":"about/#about","text":"Coming Soon~","title":"About"},{"location":"backend-docs/api-specification/","text":"API Specifications Coming Soon~","title":"APIs"},{"location":"backend-docs/api-specification/#api-specifications","text":"Coming Soon~","title":"API Specifications"},{"location":"backend-docs/cli-usages/","text":"Coming Soon~","title":"CLI Usages"},{"location":"backend-docs/database-specification/","text":"Introduction The document talks about the database schema and how things are connected. I will list all the fields in each model (table/object), and talk about the relationships it has with other model. I use Django ORM for the database accessing/writing. Some notations: FK : Foreign Key, MTM : Many To Many Relationship, OTO : One To One Relationship. Mixins I copied a description of mixins, but you can just skip it knowing that mixin is just a plugin enabling models having the mixin possess the same properties the mixin has. \"In same cases different models could have same fields and same procedures in the product life cycle. To handle these similarities without having code repetition inheritance could be used. Instead of inheriting a whole class, mixin design pattern offers us to inherit (or some says include) some methods and attributes.\" UUIDMixin id : The unique identifier of records. The value is generated by uuid.uuid4 method in the native Python library. TimeDateMixin created_time : It automatically records the time at which a record is created. modified_time : It automatically records the time at which a record is modified. PublishedMixin is_published : A field indicating whether the record having this property should be displayed publicly. User UUIDMixin username : The username of a user email : The email of a user is_verified : A field indicating whether this user passes email verification role : The role of this user, it can be either one of the following values: Administrator , Author , Translator , Visitor . date_joined : The date on which this user is created Category UUIDMixin PublishedMixin category : The category name Tutorial UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access this tutorial by typing https://domain-name.com/tutorial/url in the browser to access this tutorial name : The unique human readable id of this tutorial categories (MTM): This field links Tutorial with the Category Graph UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access the playground of this graph by typing https://domain-name.com/graph/url (format to be changed in future releases). name : The unique human readable id of this graph categories (MTM): This field links Graph with the Category authors (MTM): This field links Graph with User priority : The priority of this graph, it can be either one of the following values: Main Graph , Supplement Graph , and Trivial Graph tutorials (MTM): This field links Graph with Tutorial Code UUIDMixin TimeDateMixin tutorial (OTO): This field links Code with Tutorial code : The actual content of the Python code ExecResultJson UUIDMixin TimeDateMixin code (FK): This field links ExecResultJson with Code graph (FK): This field links ExecResultJson with Graph json : The actual json content read by the frontend to update Cytoscape graphs and the editor highlighting. {LanguageCode} {LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. authors : This link translations with User , stores the users who wrote/translate this tutorial. tutorila_anchor (OTO): This links translations with Tutorial . abstract : The content of the abstract that will be displayed on the website's abstract section. content_md : The markdown version of the tutorial text content_html : The html version of the tutorial text {LanguageCode}GraphContent {LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. This kind of tables store the info of graphs in different translations. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. abstract : The content of a short introduction of the graph graph_anchor : This link translations of graph content with Graph .","title":"Databse Schema"},{"location":"backend-docs/database-specification/#introduction","text":"The document talks about the database schema and how things are connected. I will list all the fields in each model (table/object), and talk about the relationships it has with other model. I use Django ORM for the database accessing/writing. Some notations: FK : Foreign Key, MTM : Many To Many Relationship, OTO : One To One Relationship.","title":"Introduction"},{"location":"backend-docs/database-specification/#mixins","text":"I copied a description of mixins, but you can just skip it knowing that mixin is just a plugin enabling models having the mixin possess the same properties the mixin has. \"In same cases different models could have same fields and same procedures in the product life cycle. To handle these similarities without having code repetition inheritance could be used. Instead of inheriting a whole class, mixin design pattern offers us to inherit (or some says include) some methods and attributes.\" UUIDMixin id : The unique identifier of records. The value is generated by uuid.uuid4 method in the native Python library. TimeDateMixin created_time : It automatically records the time at which a record is created. modified_time : It automatically records the time at which a record is modified. PublishedMixin is_published : A field indicating whether the record having this property should be displayed publicly.","title":"Mixins"},{"location":"backend-docs/database-specification/#user","text":"UUIDMixin username : The username of a user email : The email of a user is_verified : A field indicating whether this user passes email verification role : The role of this user, it can be either one of the following values: Administrator , Author , Translator , Visitor . date_joined : The date on which this user is created","title":"User"},{"location":"backend-docs/database-specification/#category","text":"UUIDMixin PublishedMixin category : The category name","title":"Category"},{"location":"backend-docs/database-specification/#tutorial","text":"UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access this tutorial by typing https://domain-name.com/tutorial/url in the browser to access this tutorial name : The unique human readable id of this tutorial categories (MTM): This field links Tutorial with the Category","title":"Tutorial"},{"location":"backend-docs/database-specification/#graph","text":"UUIDMixin TimeDateMixin PublishedMixin url : The unique url of this tutorial. Users can access the playground of this graph by typing https://domain-name.com/graph/url (format to be changed in future releases). name : The unique human readable id of this graph categories (MTM): This field links Graph with the Category authors (MTM): This field links Graph with User priority : The priority of this graph, it can be either one of the following values: Main Graph , Supplement Graph , and Trivial Graph tutorials (MTM): This field links Graph with Tutorial","title":"Graph"},{"location":"backend-docs/database-specification/#code","text":"UUIDMixin TimeDateMixin tutorial (OTO): This field links Code with Tutorial code : The actual content of the Python code","title":"Code"},{"location":"backend-docs/database-specification/#execresultjson","text":"UUIDMixin TimeDateMixin code (FK): This field links ExecResultJson with Code graph (FK): This field links ExecResultJson with Graph json : The actual json content read by the frontend to update Cytoscape graphs and the editor highlighting.","title":"ExecResultJson"},{"location":"backend-docs/database-specification/#languagecode","text":"{LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. authors : This link translations with User , stores the users who wrote/translate this tutorial. tutorila_anchor (OTO): This links translations with Tutorial . abstract : The content of the abstract that will be displayed on the website's abstract section. content_md : The markdown version of the tutorial text content_html : The html version of the tutorial text","title":"{LanguageCode}"},{"location":"backend-docs/database-specification/#languagecodegraphcontent","text":"{LanguageCode} should be swapped by actual language code like ENUS , ZHCN , etc. The code should only contain uppercase letters. This kind of tables store the info of graphs in different translations. UUIDMixin TimeDateMixin PublishedMixin title : The actual title that will be in different language and displayed on the website's title section. abstract : The content of a short introduction of the graph graph_anchor : This link translations of graph content with Graph .","title":"{LanguageCode}GraphContent"},{"location":"backend-docs/naming-convention/","text":"Naming Convention CLI Reader Folder The folder structure should be structured as following: . \u2514\u2500\u2500 One Tutorial \u251c\u2500\u2500 code \u2502 \u251c\u2500\u2500 entry.py \u2502 \u251c\u2500\u2500 graph-info.json \u2502 \u251c\u2500\u2500 other_modules.py \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 graphs \u2502 \u251c\u2500\u2500 graph1.json \u2502 \u251c\u2500\u2500 graph2.json \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 locale \u251c\u2500\u2500 statics \u2502 \u251c\u2500\u2500 example.jpg \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 title.en-us.md \u251c\u2500\u2500 title.zh-cn.md \u2514\u2500\u2500 ... The Root_Foler contains everything that's need to generate a tutorial page. The resources are divided into three parts: code, graphs, and locale. We will go through them one by one. code Folder The code folder contains all the python code required by this tutorial. Multiple-module/file management is not supported yet. So right now, all the code should be written in one file, the entry.py file. The CLI will detect entry.py file and import the code in it. In side entry.py file, there must be a main function, that is def main (): # do something The function has no arguments and returns None . The CLI will look for main and use it to start the program. Therefore, you can add other functions in entry.py and make sure you reference it directly or indirectly from main . We have a sight module located in bundle.sight , from which you can import tracer . tracer can be used as a function decorator and it traces the variable changes inside of the function. For more usages on tracer , check out the README.md file and the ADVANCED_USAGE.md file in the GitHub repo. If you want to use graph objects in the code, make sure the graph is already registered in the database. To reference a registered graph, you can use graph-info.json . There are two fields in the file, required_graphs and from_tutorials . Both of them must be list of strings of url (to be changed in the future) pointing to the graph object. To use the graph in the code, you must import the graph_object variable under bundle.utils.dummy_graph module. You should use it instead of creating your own graph object, since the CLI will swap the value of graph_object with actual graph objects stated in graph-info.json . graphs Folder The graph folder contains the jsons of the graphs you want to upload to the database. They must follow cyjs format. More about cyjs, please check out this link (the second example in that section). The name of the graph json file will be used as the name of the graph, which is a unique identified in the database. The url of the graph will simply be name with every <space> replaced by - . However, you can change them in the CLI to any strings you want. Additionally, every graph has a short abstract and a human readable title. Each translation of a description should be stored in a Markdown file whose file name follows the Markdown file naming convention below. In addition to the conventions below, the graph abstract should only have one paragraph, that is, one line of content in the markdown file. The extra lines will be omitted. locale Folder The locale folder contains the actual content of the tutorials. Each translation of the actual content should be stored in a Markdown file, whose file name also follows the Markdown file naming convention. The abstract of the content in that translation will be the fist paragraph of the actual content. You can modify it in the CLI or in the admin page. The statics folder under the locale folder should contain any static objects used in the Markdown translation, like images for example. The static resources must use relative path which starts with ./ . Markdown File Convention The Markdown file should be named in title.language_code.md . The title will be the default title prompted by CLI. You can of course modify it. The language code should be the code of the following supported language: en-us zh-cn Note that even English is counted as a translation. So you cannot omit the language code of an English MD file. The Markdown file may have one and only one <h1> tag, which is # in Markdown format. It will be removed during processing and will be the default title prompted by CLI.","title":"Naming Conventions"},{"location":"backend-docs/naming-convention/#naming-convention","text":"","title":"Naming Convention"},{"location":"backend-docs/naming-convention/#cli-reader-folder","text":"The folder structure should be structured as following: . \u2514\u2500\u2500 One Tutorial \u251c\u2500\u2500 code \u2502 \u251c\u2500\u2500 entry.py \u2502 \u251c\u2500\u2500 graph-info.json \u2502 \u251c\u2500\u2500 other_modules.py \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 graphs \u2502 \u251c\u2500\u2500 graph1.json \u2502 \u251c\u2500\u2500 graph2.json \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 locale \u251c\u2500\u2500 statics \u2502 \u251c\u2500\u2500 example.jpg \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 title.en-us.md \u251c\u2500\u2500 title.zh-cn.md \u2514\u2500\u2500 ... The Root_Foler contains everything that's need to generate a tutorial page. The resources are divided into three parts: code, graphs, and locale. We will go through them one by one.","title":"CLI Reader Folder"},{"location":"backend-docs/naming-convention/#code-folder","text":"The code folder contains all the python code required by this tutorial. Multiple-module/file management is not supported yet. So right now, all the code should be written in one file, the entry.py file. The CLI will detect entry.py file and import the code in it. In side entry.py file, there must be a main function, that is def main (): # do something The function has no arguments and returns None . The CLI will look for main and use it to start the program. Therefore, you can add other functions in entry.py and make sure you reference it directly or indirectly from main . We have a sight module located in bundle.sight , from which you can import tracer . tracer can be used as a function decorator and it traces the variable changes inside of the function. For more usages on tracer , check out the README.md file and the ADVANCED_USAGE.md file in the GitHub repo. If you want to use graph objects in the code, make sure the graph is already registered in the database. To reference a registered graph, you can use graph-info.json . There are two fields in the file, required_graphs and from_tutorials . Both of them must be list of strings of url (to be changed in the future) pointing to the graph object. To use the graph in the code, you must import the graph_object variable under bundle.utils.dummy_graph module. You should use it instead of creating your own graph object, since the CLI will swap the value of graph_object with actual graph objects stated in graph-info.json .","title":"code Folder"},{"location":"backend-docs/naming-convention/#graphs-folder","text":"The graph folder contains the jsons of the graphs you want to upload to the database. They must follow cyjs format. More about cyjs, please check out this link (the second example in that section). The name of the graph json file will be used as the name of the graph, which is a unique identified in the database. The url of the graph will simply be name with every <space> replaced by - . However, you can change them in the CLI to any strings you want. Additionally, every graph has a short abstract and a human readable title. Each translation of a description should be stored in a Markdown file whose file name follows the Markdown file naming convention below. In addition to the conventions below, the graph abstract should only have one paragraph, that is, one line of content in the markdown file. The extra lines will be omitted.","title":"graphs Folder"},{"location":"backend-docs/naming-convention/#locale-folder","text":"The locale folder contains the actual content of the tutorials. Each translation of the actual content should be stored in a Markdown file, whose file name also follows the Markdown file naming convention. The abstract of the content in that translation will be the fist paragraph of the actual content. You can modify it in the CLI or in the admin page. The statics folder under the locale folder should contain any static objects used in the Markdown translation, like images for example. The static resources must use relative path which starts with ./ .","title":"locale Folder"},{"location":"backend-docs/naming-convention/#markdown-file-convention","text":"The Markdown file should be named in title.language_code.md . The title will be the default title prompted by CLI. You can of course modify it. The language code should be the code of the following supported language: en-us zh-cn Note that even English is counted as a translation. So you cannot omit the language code of an English MD file. The Markdown file may have one and only one <h1> tag, which is # in Markdown format. It will be removed during processing and will be the default title prompted by CLI.","title":"Markdown File Convention"},{"location":"backend-docs/utils/","text":"Utilities Introduction This article talks about how the backend prepares data for database from user-input files. All the utilities live in the bundle module. There are three sections: GraphObjects in which all the elements of graphs are defined, seeker the variable tracing module, and utils which contains helpers used by controller . controller.py contains controller which should be the entry point of other utilities. cli.py is the CLI interacting with the user (not finished yet). GraphObjects The APIs exposed by GraphObject are listed here . This section is for developers who wants to generate graph objects. Graph.py has a function called graph_generator , which takes in a json string in cyjs format (example here , the second example in the section) and returns a Graph object. The cyjs format is extended in this module. You can create an object filed displayed in a node or an edge element, like this: \"nodes\" : [ { \"data\" : { \"id\" : 1 }, \"displayed\" : { \"degree\" : 0 } } ] All the fields in displayed will be recorded into the properties field in corresponding Node or Edge object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling node[filed_name] for example, node['degree'] . We will provide tools for adding displayed section since it's not provided by Cytoscape software. The feature is coming soon. controller The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the Recorder and Processor which we will go into later. Before going into its usage, we need to talk about TempSysPathAdder . TempSysPathAdder exists in bundle.utils.cache_file_helpers . It takes in a Path object or a string of path and add the path to system path so that the code after it can use __import__ to import the python code in that path and use it directly as a module. The following code is an example: from bundle.controller import controller from bundle.utils.cache_file_helpers import TempSysPathAdder from importlib import import_module with controller as folder_creator , \\ folder_creator ( 'cache_folder_name' ) as cache_folder , \\ TempSysPathAdder ( cache_folder ): # create file in the temp_dir and import it directly copy_file_to_temp_folder ( '/path/to/python_code' ) imported_module = import_module ( 'module_name' ) seeker The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called seeker . It is modified from PySnooper created by Ram Rachum . Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code. tracer can be imported from bundle.seeker and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example: from bundle.seeker import tracer @tracer ( watch = [ 'x' , 'y' ]) def black_box ( x , y ): x *= y y *= x return x + y And you can specify a watch list by the keyword watch . The watch list should contain strings of variables' names, like x , y , object.element , and seq[index] . Recorder and Processor The tracer needs a Recorder instance to be functional since the main function of this module is to record changes. If you are using controller , the Recorder creation and reset if managed by it (or tracer will create a Recorder instance by itself since the prerequisite is recorder not being empty). A Recorder instance maintains a changes list. Each element is a mapping that contains three fields: line , variables , and accesses . The line field represents the current line. variabels records the variable changed in this line. accesses records the accessed attributes like a variable in an object. With these data generated after running tracer , it's Processor instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).","title":"Utilities"},{"location":"backend-docs/utils/#utilities","text":"","title":"Utilities"},{"location":"backend-docs/utils/#introduction","text":"This article talks about how the backend prepares data for database from user-input files. All the utilities live in the bundle module. There are three sections: GraphObjects in which all the elements of graphs are defined, seeker the variable tracing module, and utils which contains helpers used by controller . controller.py contains controller which should be the entry point of other utilities. cli.py is the CLI interacting with the user (not finished yet).","title":"Introduction"},{"location":"backend-docs/utils/#graphobjects","text":"The APIs exposed by GraphObject are listed here . This section is for developers who wants to generate graph objects. Graph.py has a function called graph_generator , which takes in a json string in cyjs format (example here , the second example in the section) and returns a Graph object. The cyjs format is extended in this module. You can create an object filed displayed in a node or an edge element, like this: \"nodes\" : [ { \"data\" : { \"id\" : 1 }, \"displayed\" : { \"degree\" : 0 } } ] All the fields in displayed will be recorded into the properties field in corresponding Node or Edge object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling node[filed_name] for example, node['degree'] . We will provide tools for adding displayed section since it's not provided by Cytoscape software. The feature is coming soon.","title":"GraphObjects"},{"location":"backend-docs/utils/#controller","text":"The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the Recorder and Processor which we will go into later. Before going into its usage, we need to talk about TempSysPathAdder . TempSysPathAdder exists in bundle.utils.cache_file_helpers . It takes in a Path object or a string of path and add the path to system path so that the code after it can use __import__ to import the python code in that path and use it directly as a module. The following code is an example: from bundle.controller import controller from bundle.utils.cache_file_helpers import TempSysPathAdder from importlib import import_module with controller as folder_creator , \\ folder_creator ( 'cache_folder_name' ) as cache_folder , \\ TempSysPathAdder ( cache_folder ): # create file in the temp_dir and import it directly copy_file_to_temp_folder ( '/path/to/python_code' ) imported_module = import_module ( 'module_name' )","title":"controller"},{"location":"backend-docs/utils/#seeker","text":"The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called seeker . It is modified from PySnooper created by Ram Rachum . Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code. tracer can be imported from bundle.seeker and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example: from bundle.seeker import tracer @tracer ( watch = [ 'x' , 'y' ]) def black_box ( x , y ): x *= y y *= x return x + y And you can specify a watch list by the keyword watch . The watch list should contain strings of variables' names, like x , y , object.element , and seq[index] .","title":"seeker"},{"location":"backend-docs/utils/#recorder-and-processor","text":"The tracer needs a Recorder instance to be functional since the main function of this module is to record changes. If you are using controller , the Recorder creation and reset if managed by it (or tracer will create a Recorder instance by itself since the prerequisite is recorder not being empty). A Recorder instance maintains a changes list. Each element is a mapping that contains three fields: line , variables , and accesses . The line field represents the current line. variabels records the variable changed in this line. accesses records the accessed attributes like a variable in an object. With these data generated after running tracer , it's Processor instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).","title":"Recorder and Processor"},{"location":"user-manual/get-started/","text":"Get Started Introduction The get stated section is intended for writers who want to prepare their codes for tutorials. Graph Objects There are several main building blocks for a graph: Node , NodeSet , Edge , EdgeSet , Graph . In this section, we will go over these concepts. Node Every Node object has a unique id and a name. When the name of a node is not specified specifically, it is filled with it's id and a prefix. For Node , the default prefix is n . So the name of a node with id 1 is n1 . Two Node instances are equal if and only if their ids are equal. Every Node instance has a properties field that collects the properties of the instance. The properties will be displayed in a tooltip once your mouse curser is hovered on the node. Some magic methods are overridden so that you can use the basic operators like == and != . The equality follows the rules above. # assume n1 and n2 are Node instances n1 == n2 # if the id of n1 is equal to that of n2 n1 != n2 # the negation of equality above n1 > n2 # if the id of n1 is bigger than n2 n1 < n2 # if the id of n1 is smaller than n2 n1 >= n2 n1 <= n2 The representation string of a Node object is Node(id: the_node_id) . NodeSet NodeSet describes a set of nodes. The elements in the set are unique. It is also not editable (for now). You can also use python native operators to get the relationships between Node and NodeSet . # assume n1, n2, and n3 are Node instances; node_set is a NodeSet instance # the ids of the three nodes are 1, 2, 3 respectively # also, n1 and n3 are in node_set while n2 is not len ( node_set ) == 2 # evaluated True node_set [ 1 ] == n1 # evaluated True n3 in node_set # evaluated True n2 not in node_set # evaluated True for node in node_set : print ( node ) # this will print Node(id: 1) and Node(id: 3) # on separated lines print ( node_set ) # print out [Node(id: 1), Node(id: 3) Edge Edge is like Node since every instance of Edge has a id and name . The same rules described above are also applied to Edge . The properties field is also present in Edge . It can be accessed using the same method. An additional field in an Edge instance is directed , which indicates whether the edge is directed. Naturally, instances of Edge also support native python operators. But there are more in Edge . # assuming n1, n2 and n3 are Node instances # e1 is an Edge instance which is from n1 to n2 n1 in e1 # evaluated True n3 in e1 # evaluated False for node in edge : print ( node ) # this will print Node(id: 1) and Node(id: 2) len ( e1 ) # is equal to 2 and does not make sense at all The representation string of a Edge object is Edge(id: the_edge_id) EdgeSet The EdgeSet is similar to NodeSet . All the operators are supported. Graph The a Graph instance has a node set and an edge set which are represented by NodeSet and EdgeSet . You can access the node set by calling graph.nodes or graph.V assuming graph is a Graph instance. Similarly, the edge set can be accessed by graph.edges or graph.E . # assuming n1, n2, n3, and n4 are nodes in a graph named g1 # e1, e2, e3 are edges n1 in g1 # evaluated True e1 in g1 # evaluated True g1 . empty () # evaluated False since the graph is not empty File conventions The files you submit to the backend must contain a entry.py file. The backend will import entry.py and select functions with special prefix and postfix to run tracer on. The files can contain other python files and files other file python source format that may severs as data preparations, etc. But the backend will not import those files. You need to explicit append @tracer() to the functions and supply a list of variables which you want to trace.","title":"Get Started"},{"location":"user-manual/get-started/#get-started","text":"","title":"Get Started"},{"location":"user-manual/get-started/#introduction","text":"The get stated section is intended for writers who want to prepare their codes for tutorials.","title":"Introduction"},{"location":"user-manual/get-started/#graph-objects","text":"There are several main building blocks for a graph: Node , NodeSet , Edge , EdgeSet , Graph . In this section, we will go over these concepts.","title":"Graph Objects"},{"location":"user-manual/get-started/#node","text":"Every Node object has a unique id and a name. When the name of a node is not specified specifically, it is filled with it's id and a prefix. For Node , the default prefix is n . So the name of a node with id 1 is n1 . Two Node instances are equal if and only if their ids are equal. Every Node instance has a properties field that collects the properties of the instance. The properties will be displayed in a tooltip once your mouse curser is hovered on the node. Some magic methods are overridden so that you can use the basic operators like == and != . The equality follows the rules above. # assume n1 and n2 are Node instances n1 == n2 # if the id of n1 is equal to that of n2 n1 != n2 # the negation of equality above n1 > n2 # if the id of n1 is bigger than n2 n1 < n2 # if the id of n1 is smaller than n2 n1 >= n2 n1 <= n2 The representation string of a Node object is Node(id: the_node_id) .","title":"Node"},{"location":"user-manual/get-started/#nodeset","text":"NodeSet describes a set of nodes. The elements in the set are unique. It is also not editable (for now). You can also use python native operators to get the relationships between Node and NodeSet . # assume n1, n2, and n3 are Node instances; node_set is a NodeSet instance # the ids of the three nodes are 1, 2, 3 respectively # also, n1 and n3 are in node_set while n2 is not len ( node_set ) == 2 # evaluated True node_set [ 1 ] == n1 # evaluated True n3 in node_set # evaluated True n2 not in node_set # evaluated True for node in node_set : print ( node ) # this will print Node(id: 1) and Node(id: 3) # on separated lines print ( node_set ) # print out [Node(id: 1), Node(id: 3)","title":"NodeSet"},{"location":"user-manual/get-started/#edge","text":"Edge is like Node since every instance of Edge has a id and name . The same rules described above are also applied to Edge . The properties field is also present in Edge . It can be accessed using the same method. An additional field in an Edge instance is directed , which indicates whether the edge is directed. Naturally, instances of Edge also support native python operators. But there are more in Edge . # assuming n1, n2 and n3 are Node instances # e1 is an Edge instance which is from n1 to n2 n1 in e1 # evaluated True n3 in e1 # evaluated False for node in edge : print ( node ) # this will print Node(id: 1) and Node(id: 2) len ( e1 ) # is equal to 2 and does not make sense at all The representation string of a Edge object is Edge(id: the_edge_id)","title":"Edge"},{"location":"user-manual/get-started/#edgeset","text":"The EdgeSet is similar to NodeSet . All the operators are supported.","title":"EdgeSet"},{"location":"user-manual/get-started/#graph","text":"The a Graph instance has a node set and an edge set which are represented by NodeSet and EdgeSet . You can access the node set by calling graph.nodes or graph.V assuming graph is a Graph instance. Similarly, the edge set can be accessed by graph.edges or graph.E . # assuming n1, n2, n3, and n4 are nodes in a graph named g1 # e1, e2, e3 are edges n1 in g1 # evaluated True e1 in g1 # evaluated True g1 . empty () # evaluated False since the graph is not empty","title":"Graph"},{"location":"user-manual/get-started/#file-conventions","text":"The files you submit to the backend must contain a entry.py file. The backend will import entry.py and select functions with special prefix and postfix to run tracer on. The files can contain other python files and files other file python source format that may severs as data preparations, etc. But the backend will not import those files. You need to explicit append @tracer() to the functions and supply a list of variables which you want to trace.","title":"File conventions"}]}