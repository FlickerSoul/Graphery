{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Graphery Documentations Introduction Comming Soon~ Usage Please use the navigation to get more info~","title":"Home"},{"location":"#welcome-to-graphery-documentations","text":"","title":"Welcome to Graphery Documentations"},{"location":"#introduction","text":"Comming Soon~","title":"Introduction"},{"location":"#usage","text":"Please use the navigation to get more info~","title":"Usage"},{"location":"about/","text":"About comming soon~","title":"About"},{"location":"about/#about","text":"comming soon~","title":"About"},{"location":"backend-docs/api-specification/","text":"API Specifications comming soon~","title":"APIs"},{"location":"backend-docs/api-specification/#api-specifications","text":"comming soon~","title":"API Specifications"},{"location":"backend-docs/utils/","text":"Utilities Introduction This article talks about how the backend prepares data for database from user-input files. All the utilities live in the bundle module. There are three sections: GraphObjects in which all the elements of graphs are defined, seeker the variable tracing module, and utils which contains helpers used by controller . controller.py contains controller which should be the entry point of other utilities. cli.py is the CLI interacting with the user (not finished yet). GraphObjects The APIs exposed by GraphObject are listed here . This section is for developers who wants to generate graph objects. Graph.py has a function called graph_generator , which takes in a json string in cyjs format (example here , the second example in the section) and returns a Graph object. The cyjs format is extended in this module. You can create an object filed displayed in a node or an edge element, like this: \"nodes\": [ { \"data\": { \"id\": 1 }, \"displayed\": { \"degree\": 0 } } ] All the fields in displayed will be recorded into the properties field in corresponding Node or Edge object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling node[filed_name] for example, node['degree'] . We will provide tools for adding displayed section since it's not provided by Cytoscape software. The feature is coming soon. controller The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the Recorder and Processor which we will go into later. Before going into its usage, we need to talk about TempSysPathAdder . TempSysPathAdder exists in bundle.utils.cache_file_helpers . It takes in a Path object or a string of path and add the path to system path so that the code after it can use __import__ to import the python code in that path and use it directly as a module. The following code is an example: from bundle.controller import controller from bundle.utils.cache_file_helpers import TempSysPathAdder from importlib import import_module with controller as folder_creator, \\ folder_creator('cache_folder_name') as cache_folder, \\ TempSysPathAdder(cache_folder): # create file in the temp_dir and import it directly copy_file_to_temp_folder('/path/to/python_code') imported_module = import_module('module_name') seeker The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called seeker . It is modified from PySnooper created by Ram Rachum . Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code. tracer can be imported from bundle.seeker and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example: from bundle.seeker import tracer @tracer(watch=['x', 'y']) def black_box(x, y): x *= y y *= x return x + y And you can specify a watch list by the keyword watch . The watch list should contain strings of variables' names, like x , y , object.element , and seq[index] . Recorder and Processor The tracer needs a Recorder instance to be functional since the main function of this module is to record changes. If you are using controller , the Recorder creation and reset if managed by it (or tracer will create a Recorder instance by itself since the prerequisite is recorder not being empty). A Recorder instance maintains a changes list. Each element is a mapping that contains three fields: line , variables , and accesses . The line field represents the current line. variabels records the variable changed in this line. accesses records the accessed attributes like a variable in an object. With these data generated after running tracer , it's Processor instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).","title":"Utilities"},{"location":"backend-docs/utils/#utilities","text":"","title":"Utilities"},{"location":"backend-docs/utils/#introduction","text":"This article talks about how the backend prepares data for database from user-input files. All the utilities live in the bundle module. There are three sections: GraphObjects in which all the elements of graphs are defined, seeker the variable tracing module, and utils which contains helpers used by controller . controller.py contains controller which should be the entry point of other utilities. cli.py is the CLI interacting with the user (not finished yet).","title":"Introduction"},{"location":"backend-docs/utils/#graphobjects","text":"The APIs exposed by GraphObject are listed here . This section is for developers who wants to generate graph objects. Graph.py has a function called graph_generator , which takes in a json string in cyjs format (example here , the second example in the section) and returns a Graph object. The cyjs format is extended in this module. You can create an object filed displayed in a node or an edge element, like this: \"nodes\": [ { \"data\": { \"id\": 1 }, \"displayed\": { \"degree\": 0 } } ] All the fields in displayed will be recorded into the properties field in corresponding Node or Edge object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling node[filed_name] for example, node['degree'] . We will provide tools for adding displayed section since it's not provided by Cytoscape software. The feature is coming soon.","title":"GraphObjects"},{"location":"backend-docs/utils/#controller","text":"The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the Recorder and Processor which we will go into later. Before going into its usage, we need to talk about TempSysPathAdder . TempSysPathAdder exists in bundle.utils.cache_file_helpers . It takes in a Path object or a string of path and add the path to system path so that the code after it can use __import__ to import the python code in that path and use it directly as a module. The following code is an example: from bundle.controller import controller from bundle.utils.cache_file_helpers import TempSysPathAdder from importlib import import_module with controller as folder_creator, \\ folder_creator('cache_folder_name') as cache_folder, \\ TempSysPathAdder(cache_folder): # create file in the temp_dir and import it directly copy_file_to_temp_folder('/path/to/python_code') imported_module = import_module('module_name')","title":"controller"},{"location":"backend-docs/utils/#seeker","text":"The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called seeker . It is modified from PySnooper created by Ram Rachum . Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code. tracer can be imported from bundle.seeker and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example: from bundle.seeker import tracer @tracer(watch=['x', 'y']) def black_box(x, y): x *= y y *= x return x + y And you can specify a watch list by the keyword watch . The watch list should contain strings of variables' names, like x , y , object.element , and seq[index] .","title":"seeker"},{"location":"backend-docs/utils/#recorder-and-processor","text":"The tracer needs a Recorder instance to be functional since the main function of this module is to record changes. If you are using controller , the Recorder creation and reset if managed by it (or tracer will create a Recorder instance by itself since the prerequisite is recorder not being empty). A Recorder instance maintains a changes list. Each element is a mapping that contains three fields: line , variables , and accesses . The line field represents the current line. variabels records the variable changed in this line. accesses records the accessed attributes like a variable in an object. With these data generated after running tracer , it's Processor instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).","title":"Recorder and Processor"},{"location":"user-manual/get-started/","text":"Get Started Introduction The get stated section is intended for writers who want to prepare their codes for tutorials. Graph Objects There are several main building blocks for a graph: Node , NodeSet , Edge , EdgeSet , Graph . In this section, we will go over these concepts. Node Every Node object has a unique id and a name. When the name of a node is not specified specifically, it is filled with it's id and a prefix. For Node , the default prefix is n . So the name of a node with id 1 is n1 . Two Node instances are equal if and only if their ids are equal. Every Node instance has a properties field that collects the properties of the instance. The properties will be displayed in a tooltip once your mouse curser is hovered on the node. Some magic methods are overridden so that you can use the basic operators like == and != . The equality follows the rules above. # assume n1 and n2 are Node instances n1 == n2 # if the id of n1 is equal to that of n2 n1 != n2 # the negation of equality above n1 > n2 # if the id of n1 is bigger than n2 n1 < n2 # if the id of n1 is smaller than n2 n1 >= n2 n1 <= n2 The representation string of a Node object is Node(id: the_node_id) . NodeSet NodeSet describes a set of nodes. The elements in the set are unique. It is also not editable (for now). You can also use python native operators to get the relationships between Node and NodeSet . # assume n1, n2, and n3 are Node instances; node_set is a NodeSet instance # the ids of the three nodes are 1, 2, 3 respectively # also, n1 and n3 are in node_set while n2 is not len(node_set) == 2 # evaluated True node_set[1] == n1 # evaluated True n3 in node_set # evaluated True n2 not in node_set # evaluated True for node in node_set: print(node) # this will print Node(id: 1) and Node(id: 3) # on separated lines print(node_set) # print out [Node(id: 1), Node(id: 3) Edge Edge is like Node since every instance of Edge has a id and name . The same rules described above are also applied to Edge . The properties field is also present in Edge . It can be accessed using the same method. An additional field in an Edge instance is directed , which indicates whether the edge is directed. Naturally, instances of Edge also support native python operators. But there are more in Edge . # assuming n1, n2 and n3 are Node instances # e1 is an Edge instance which is from n1 to n2 n1 in e1 # evaluated True n3 in e1 # evaluated False for node in edge: print(node) # this will print Node(id: 1) and Node(id: 2) len(e1) # is equal to 2 and does not make sense at all The representation string of a Edge object is Edge(id: the_edge_id) EdgeSet The EdgeSet is similar to NodeSet . All the operators are supported. Graph The a Graph instance has a node set and an edge set which are represented by NodeSet and EdgeSet . You can access the node set by calling graph.nodes or graph.V assuming graph is a Graph instance. Similarly, the edge set can be accessed by graph.edges or graph.E . # assuming n1, n2, n3, and n4 are nodes in a graph named g1 # e1, e2, e3 are edges n1 in g1 # evaluated True e1 in g1 # evaluated True g1.empty() # evaluated False since the graph is not empty File conventions The files you submit to the backend must contain a entry.py file. The backend will import entry.py and select functions with special prefix and postfix to run tracer on. The files can contain other python files and files other file python source format that may severs as data preparations, etc. But the backend will not import those files. You need to explicit append @tracer() to the functions and supply a list of variables which you want to trace.","title":"Get Started"},{"location":"user-manual/get-started/#get-started","text":"","title":"Get Started"},{"location":"user-manual/get-started/#introduction","text":"The get stated section is intended for writers who want to prepare their codes for tutorials.","title":"Introduction"},{"location":"user-manual/get-started/#graph-objects","text":"There are several main building blocks for a graph: Node , NodeSet , Edge , EdgeSet , Graph . In this section, we will go over these concepts.","title":"Graph Objects"},{"location":"user-manual/get-started/#node","text":"Every Node object has a unique id and a name. When the name of a node is not specified specifically, it is filled with it's id and a prefix. For Node , the default prefix is n . So the name of a node with id 1 is n1 . Two Node instances are equal if and only if their ids are equal. Every Node instance has a properties field that collects the properties of the instance. The properties will be displayed in a tooltip once your mouse curser is hovered on the node. Some magic methods are overridden so that you can use the basic operators like == and != . The equality follows the rules above. # assume n1 and n2 are Node instances n1 == n2 # if the id of n1 is equal to that of n2 n1 != n2 # the negation of equality above n1 > n2 # if the id of n1 is bigger than n2 n1 < n2 # if the id of n1 is smaller than n2 n1 >= n2 n1 <= n2 The representation string of a Node object is Node(id: the_node_id) .","title":"Node"},{"location":"user-manual/get-started/#nodeset","text":"NodeSet describes a set of nodes. The elements in the set are unique. It is also not editable (for now). You can also use python native operators to get the relationships between Node and NodeSet . # assume n1, n2, and n3 are Node instances; node_set is a NodeSet instance # the ids of the three nodes are 1, 2, 3 respectively # also, n1 and n3 are in node_set while n2 is not len(node_set) == 2 # evaluated True node_set[1] == n1 # evaluated True n3 in node_set # evaluated True n2 not in node_set # evaluated True for node in node_set: print(node) # this will print Node(id: 1) and Node(id: 3) # on separated lines print(node_set) # print out [Node(id: 1), Node(id: 3)","title":"NodeSet"},{"location":"user-manual/get-started/#edge","text":"Edge is like Node since every instance of Edge has a id and name . The same rules described above are also applied to Edge . The properties field is also present in Edge . It can be accessed using the same method. An additional field in an Edge instance is directed , which indicates whether the edge is directed. Naturally, instances of Edge also support native python operators. But there are more in Edge . # assuming n1, n2 and n3 are Node instances # e1 is an Edge instance which is from n1 to n2 n1 in e1 # evaluated True n3 in e1 # evaluated False for node in edge: print(node) # this will print Node(id: 1) and Node(id: 2) len(e1) # is equal to 2 and does not make sense at all The representation string of a Edge object is Edge(id: the_edge_id)","title":"Edge"},{"location":"user-manual/get-started/#edgeset","text":"The EdgeSet is similar to NodeSet . All the operators are supported.","title":"EdgeSet"},{"location":"user-manual/get-started/#graph","text":"The a Graph instance has a node set and an edge set which are represented by NodeSet and EdgeSet . You can access the node set by calling graph.nodes or graph.V assuming graph is a Graph instance. Similarly, the edge set can be accessed by graph.edges or graph.E . # assuming n1, n2, n3, and n4 are nodes in a graph named g1 # e1, e2, e3 are edges n1 in g1 # evaluated True e1 in g1 # evaluated True g1.empty() # evaluated False since the graph is not empty","title":"Graph"},{"location":"user-manual/get-started/#file-conventions","text":"The files you submit to the backend must contain a entry.py file. The backend will import entry.py and select functions with special prefix and postfix to run tracer on. The files can contain other python files and files other file python source format that may severs as data preparations, etc. But the backend will not import those files. You need to explicit append @tracer() to the functions and supply a list of variables which you want to trace.","title":"File conventions"}]}