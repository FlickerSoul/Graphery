# Utilities

## Introduction

This article talks about how the backend prepares data for database from user-input files.

All the utilities live in the `bundle` module. There are three sections: `GraphObjects` in which all the elements of graphs are defined, `seeker` the variable tracing module, and `utils` which contains helpers used by `controller`. `controller.py` contains `controller` which should be the entry point of other utilities. 

## `GraphObjects`

The APIs exposed by `GraphObject` are listed [here](../user-manual/get-started.md). This section is for developers who wants to generate graph objects.

`Graph.py` has a function called `graph_generator`, which takes in a json string in `cyjs` format which is described in the following example. 

```json
{
  "elements":{
    "nodes":[
      {
        "data":{
          "id":"a"
        }
      },
      {
        "data":{
          "id":"b"
        }
      }
    ],
    "edges":[
      {
        "data":{
          "id":"ab",
          "source":"a",
          "target":"b"
        }
      }
    ]
  },
  "layout":{
    "name":"dagre",
  },
  "style":[
    {
      "selector":"node",
      "style":{
        "label":"data(id)"
      }
    }
  ]
}
```

The JSON content must contain `elements`. There is a default global layout added to the `style` section. If you want to specify the layout engine, please change the name of the layout. The available layout engines are 

```text
dagre  // used for directed acycle graphs
fcose  // https://github.com/iVis-at-Bilkent/cytoscape.js-fcose
preset // predefined layout => does not apply any layout engine
random // random layout
```

The `cyjs` format is extended in this module. You can create an object filed `displayed` in a node or an edge element, like this:

```javascript
"nodes": [
    {
        "data": {
            "id": 1
        },
        "displayed": {
            "degree": 0
        }
    }
]
```

All the fields in `displayed` will be recorded into the `properties` field in corresponding `Node` or `Edge` object. And those fields will be displayed on the graph section as contents in a tooltip attaching to that object. You can access the properties by calling `node[filed_name]` for example, `node['degree']`.

We will provide tools for adding `displayed` section since it's not provided by Cytoscape software. The feature is coming soon.

<!-- Talk about ID guideline -->

## `controller`

The controller should be the entry point. Since it creates a temporary folder for you and destroy it afterward, and, furthermore, reset the `Recorder` and `Processor` which we will go into later. Before going into its usage, we need to talk about `TempSysPathAdder`.

`TempSysPathAdder` exists in `bundle.utils.cache_file_helpers`. It takes in a `Path` object or a string of path and add the path to system path so that the code after it can use `__import__` to import the python code in that path and use it directly as a module.

The following code is an example:

```python
from bundle.controller import controller
from bundle.utils.cache_file_helpers import TempSysPathAdder
from importlib import import_module

with controller as folder_creator, \
     folder_creator('cache_folder_name') as cache_folder, \
     TempSysPathAdder(cache_folder):
     # create file in the temp_dir and import it directly
     copy_file_to_temp_folder('/path/to/python_code')
     imported_module = import_module('module_name')
```

## `seeker`

The editor on the frontend presenting the step-by-step debugger-like function relies on data generated by a python module called `seeker`. It is modified from [PySnooper](https://github.com/cool-RR/PySnooper/tree/master/pysnooper) created by [Ram Rachum](https://github.com/cool-RR). Seeker takes in a list of names of variables, and it will trace the changes of those variables during executing code.

`tracer` can be imported from `bundle.seeker` and used as a decorator. As all decorators do, it can be prefixed before a class or a function, like the following example:

```python
from bundle.seeker import tracer

@tracer(watch=['x', 'y'])
def black_box(x, y):
    x *= y
    y *= x
    return x + y
```

And you can specify a watch list by the keyword `watch`. The watch list should contain strings of variables' names, like `x`, `y`, `object.element`, and `seq[index]`.

<!-- You can add more advanced usages -->

## `Recorder` and `Processor`

The `tracer` needs a `Recorder` instance to be functional since the main function of this module is to record changes. If you are using `controller`, the `Recorder` creation and reset if managed by it (or `tracer` will create a `Recorder` instance by itself since the prerequisite is recorder not being empty). A `Recorder` instance maintains a `changes` list. Each element is a mapping that contains three fields: `line`, `variables`, and `accesses`.

The `line` field represents the current line. `variabels` records the variable changed in this line. `accesses` records the accessed attributes like a variable in an object.

With these data generated after running `tracer`, it's `Processor` instance's job to generate useful data that can be read by frontend javascript api. (implementations coming soon).
